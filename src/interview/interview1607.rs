use crate::interview::Solution;

#[allow(unused)]
impl Solution {
    pub fn maximum(a: i32, b: i32) -> i32 {
        // 方法1
        // 想办法得到a - b是正还是负，这里可以通过移位操作知道符号位是1还是0（正或负）
        // 如果是正，令x = 1, y = 0： a * x + b * y就能留下a
        // 反之令x = 0, y = 1就能留下b
        // 也即是我们要找到x 与 y 的相互转换的公式
        // 这里有几种方式都可以办到
        // 1. 0取反是-1，然后再利用 & 1消掉高位最后得到1，也即是 !0 & 1 = 1
        //    而1取反是111...10，再消高位得到0即是， !1 & 1 = 1
        //    0 直接消高位得到本身，也即是 0 & 1 = 0
        //    1 直接消高位得到本身，也即是 1 & 1 = 1
        //    x & 1 与  !x & 1 是互为相反的。
        // 2. 上面那个实际上复杂了一点点，其实数学运算也是可以的
        //    我们直接用1 - x 即可，如果是x = 1,自然就是0，如果x = 0,自然就是1
        //    x 与 1 - x 是互为相反的。
        // Passed 0ms 1.9mb
        let x = ((a as i64 - b as i64) >> 63) as i32 + 1;
        a * (x & 1) + b * (!x & 1)
    }
}

#[test]
fn test() {
    assert_eq!(Solution::maximum(1, 2), 2);
    assert_eq!(Solution::maximum(2147483647, -2147483648), 2147483647);
}