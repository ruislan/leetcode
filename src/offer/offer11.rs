use crate::offer::Solution;

impl Solution {
    // 本题同q154
    pub fn min_array(numbers: Vec<i32>) -> i32 {
        // 方法1
        // 线性查找，O(n)，从1..n，如果numbers[n - 1] > numbers[n]，返回numbers[n]
        // 如果没找到，返回numbers[0]

        // 方法2
        // 前提是升序数组旋转，我们要考虑三种情况，
        // 第一种，第一个数字是最小的
        // 第二种，最后一个数字是最小的
        // 第三种，中间某个数字是最小的
        // 所以这里我们定义l,r,m分别代表左，右，中，初始化l = 0 , r = len - 1,
        // 我们不断裁剪数组，最后来锁定这个数字，一定会有一个最小数字，
        // 首先计算m = (l + r) / 2，然后 取出l, r, m的值
        // 如果vl <= vm <= vr，则说明是第一种情况，那么直接返回vl
        // 如果vl >= vm >= vr，则说明是第二种情况，那么直接返回vr
        // 上述都不是，说明在中间，现在我们就要看是在左边还是在右边
        // 。。。
        0
    }
}