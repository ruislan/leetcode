
# 笔记

## 准备

位运算是要牢记的，数据结构和常用算法是必须熟悉熟记的。
你所使用的语言的标准库函数也是必须熟记的。
当然，刷题本身也是对这些的熟悉过程。

## 读题

时刻要注意读题，因为有些坑就在题干中，仔细读题之后能得到答案。
要注意题目中所有出现的内容的特性，

例子1，某个数字出现了两次，那么意味着这个数字相加能够被2整除，这个数字能够被异或消除等等
，列出所有的特性，然后根据题目的要求看哪些特性是所需要的再进行选择。

例子2，数组是有序的，那么意味着可以采用二分查找或者二分的变体，那么二分查找还可以解决某个
连续相等数字的上界、下界等等。

## 经典题型

经典题型都是我认为非常棒，能够开阔思路，得到启发的好题。值得无数次的回味。

* offer42，这道题算是一道动态规划题，也算是一道总结规律的题，非常具有启发性。
* offer53_i，这是一道经典的二分查找扩展应用。
* offer56_ii，这是一道经典的位操作应用。
* offer57_ii，这是一道经典的滑动窗口。
* offer62，这是一道约瑟夫环的算法解决问题。有兴趣可以模拟每次计算进行公式推导。

## 技巧总结

### 连续数字

连续数字，例如1,2,3,4,5..这种，或者1,3,5,7..这种连续的数字，
* 要记住等差数列求和公式Sn = n * (A1 + An) / 2，这个n可以是 An - A1 + 1。
* 要注意是有序的，有序就意味着可以二分查找
* 要注意滑动窗口，滑动窗口意味着可以两端左右移动，直到左边等于右边
* 要注意前序和

### 数组中找唯一类

这类型的题，要注意位操作，记住异或是可以清除掉两个相同数字的，同时要注意如果在某一个粒度
上解决不了问题，可以到更细或者更粗的粒度上去解决，这取决于题目本身，这个思想我叫它放大思想，
如果在这个粒度上解决不了问题，就把这个粒度放大到更细的粒度去思考，相反，也有缩小粒度到更粗
的粒度去思考。

例如，数字就可以看做二进制组成的，可以把二进制作为存储bool值的数组。

### 异或类

XOR 有很多有用的特性：
````
    x xor x=0
    0 xor x=x
    2x xor (2x+1)=1
````

### 日期类

遇到日期类的题目，首先想到的就是闰年，即是能被4整除但不能被100整除，或者是能被400整除的。
闰年是366天，在2月份要多1天。


## 树

拿到树的题自然先想到的有几个，
* 树是特殊的图，那么广度优先和深度优先就能使用，广度优先用queue，深度优先用stack
* 树的前中后序遍历，用递归很简单
    * 前序： 中 左 右
    * 中序： 左 中 右
    * 后序： 左 右 中
```rust
  fn pre_order(node: Node) {
      process(node);
      pre_order(node.left);
      pre_order(node.right);
  }

  fn in_order(node: Node) {
      in_order(node.left);
      process(node);
      in_order(node.right);
  }

  fn post_order(node: Node) {
      post_order(node.left);
      post_order(node.right);
      process(node);
  }
```