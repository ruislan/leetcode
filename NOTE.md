# 笔记

## 准备

位运算是要牢记的，数据结构和常用算法是必须熟悉熟记的。 你所使用的语言的标准库函数也是必须熟记的。 当然，刷题本身也是对这些的熟悉过程。

## 读题

时刻要注意读题，因为有些坑就在题干中，仔细读题之后能得到答案。 要注意题目中所有出现的内容的特性，

例子1，某个数字出现了两次，那么意味着这个数字相加能够被2整除，这个数字能够被异或消除等等 ，列出所有的特性，然后根据题目的要求看哪些特性是所需要的再进行选择。

例子2，数组是有序的，那么意味着可以采用二分查找或者二分的变体，那么二分查找还可以解决某个 连续相等数字的上界、下界等等。

## 收藏题型

收藏题型都是我自认为非常棒，能够开阔思路，得到启发，值得无数次回味的经典题。

### 二分查找

* q34，二分查找找上下界，经典中的经典。
* offer53_i，二分查找扩展应用。
* interview0803， 二分查找扩展应用。

### 链表

* q19， Rust如何使用raw指针和删除链表的指定节点
* q147/q148， 要用Rust玩链表之前，可以用来热身
* q234， 回文和链表的翻转，以及Rust的所有权机制

### 排序

* q164， 深刻理解桶排序
* q493， 归并排序的应用

### 动态规划

* offer42，这道题算是一道动态规划题，也算是一道总结规律的题，非常具有启发性。
* q64， 动态规划，最短路径
* q123， 购买股票的最佳时机系列，这个系列全都是动态规划，可以一次性复习。
* q416， 动态规划，典型的背包问题
* q514， 动态规划的更多应用
* q714， 动态规划入门，掌握更多动态规划形态
* q1143， 教科书级别的动态规划应用，最长子公共串，这个问题可以用来解决DNA的相似度。

### 贪心算法

* q316， 字符串加贪心的应用
* q621， 贪心算法的应用
* q659， 贪心算法的应用
* q649， 贪心算法的应用
* q738， 本来很普通的一道贪心算法的应用，但是有一个大神的思路值得回味

### 并查集

* q684， 并查集的经典应用，成环检测
* q803， 并查集的高级应用，极致细节，思路爆发
* q947， 并查集的经典应用，并入集合

### 其他

* offer56_ii，这是一道经典的位操作应用。
* offer57_ii，这是一道经典的滑动窗口。
* offer62，这是一道约瑟夫环的算法解决问题。有兴趣可以模拟每次计算进行公式推导。
* q135， 数组中值的拐点是要注意的地方，参数的记录选择也很重要，是记录方向呢？还是记录数量呢？还是记录拐点值呢？
* q220， 数组、二分查找、二叉平衡树
* q239， 数组、双端队列
* q283， 数组的原地移动
* q842， 经典回溯

## 技巧总结

### 连续数字

连续数字，例如1,2,3,4,5..这种，或者1,3,5,7..这种连续的数字，

* 要记住等差数列求和公式Sn = n * (A1 + An) / 2，这个n可以是 An - A1 + 1。
* 要注意是有序的，有序就意味着可以二分查找
* 要注意滑动窗口，滑动窗口意味着可以两端左右移动，直到左边等于右边
* 要注意前序和

### 数组中找唯一类

这类型的题，要注意位操作，记住异或是可以清除掉两个相同数字的，同时要注意如果在某一个粒度 上解决不了问题，可以到更细或者更粗的粒度上去解决，这取决于题目本身，这个思想我叫它放大思想，
如果在这个粒度上解决不了问题，就把这个粒度放大到更细的粒度去思考，相反，也有缩小粒度到更粗 的粒度去思考。

例如，数字就可以看做二进制组成的，可以把二进制作为存储bool值的数组。

### 异或类

XOR 有很多有用的特性：

````
    x xor x=0
    0 xor x=x
    2x xor (2x+1)=1
````

### 日期类

遇到日期类的题目，首先想到的就是闰年，即是能被4整除但不能被100整除，或者是能被400整除的。 闰年是366天，在2月份要多1天。

## 树

拿到树的题自然先想到的有几个，

* 树是特殊的图，那么广度优先和深度优先就能使用，广度优先用queue，深度优先用stack
* 树的前中后序遍历，用递归很简单，非递归都用stack，后序的非递归遍历稍微难一点，但是
    * 前序： 中 左 右
    * 中序： 左 中 右
    * 后序： 左 右 中

```rust
  fn pre_order(node: Node) {
    process(node);
    pre_order(node.left);
    pre_order(node.right);
}

fn pre_order_iter(node: Node) {
    let mut stack = vec![node];
    while !stack.is_empty() {
        node = stack.pop();
        if node != None {
            process(node);
            stack.push(node.right);
            stack.push(node.left);
        }
    }
}
```

```rust
  fn in_order(node: Node) {
    in_order(node.left);
    process(node);
    in_order(node.right);
}

fn in_order_iter(node: Node) {
    let mut stack = vec![node];
    while !stack.is_empty() {
        node = stack.pop();
        if node != None {
            if node.left != None {
                stack.push(node);
                stack.push(node.left);
            } else {
                process(node);
                stack.push(node.right);
            }
        }
    }
}
```

```rust
  fn post_order(node: Node) {
    post_order(node.left);
    post_order(node.right);
    process(node);
}
```

注意：很多Rust的初学者可能都知道clone是一个昂贵的操作，它会拷贝所有的内容，但是Rc不一样， 它只会新增一个指针和引用计数，并不昂贵，所以我刚开始做树的题的时候也觉得clone是不是拷贝了
一棵树，但是想不出更好的办法，想着先通过题吧，但是发现速度正常，内存正常啊，按道理clone会有很昂贵的 开销，然后看了一下Rc的源码，发现clone的注释就是新增一个pointer，然后引用计数增加1，哦，知识又增加了，
然后又搜了一下GitHub，发现有人在吐槽Rc的clone方法不应该叫clone方法，要不叫ref或者叫new_ref也行，嗯，我懂他。


